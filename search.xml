<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Session</title>
    <url>/2022/11/25/Session/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><hr>
<blockquote>
<p>Cookie, Session, Token</p>
</blockquote>
<p>Cookie： <del>术语小饼干</del>，是保存在客户端的一小份数据(不允许超过4KB)<br>Session： 术语叫会话控制是存放在服务端的一份数据，同时是一种在客户端与服务服务端之间保持状态的解决方案<br>Token：令牌，是校验的凭证，可以理解为cookie中存的session id亦或是存在localstorage中的jwt字符串</p>
<p>Q：为什么我们登录过一次之后下一次再访问就不需要登录了？<br>A：众所周知HTTP是无状态协议，那么解决上述问题的通用流程如下：</p>
<p>(1)首次登录：客户端发送请求携带登录信息访问服务端<br>(2)颁发令牌：服务端校验用户账户密码正确后返回客户端一个令牌(Token)<br>(3)再次访问：客户端把Token保存在(Cookie, LoaclStroage)等地方以后的每次请求都携带此令牌</p>
<p>目前比较常用的方式有Cookie-Session, JWT这两种方式都是满足上述的通用流程但又有莫大的差别概述如下</p>
<p>Cookie-Session(有状态):<br>(1)客户端发送请求携带登录信息访问服务端。<br>(2)服务端校验用户账户密码正确后，会在服务端新建一份session同时把session的id返回给客户端一般保存在cookie中。<br>(3)以后的每次请求都会携带cookie中的token信息(session Id)和服务端保存的session做校验。</p>
<p>JSON-Web-Token(无状态)<br>(1)客户端发送请求携带登录信息访问服务端。<br>(2)服务端校验用户账户密码正确后，会对用户信息，签发时间，过期时间加密生成一段字符串返回给客户端一般保存在LocalStorage中。<br>(3)以后的每次请求都会在headers的Authorization中携带token信息送给服务端解析校验。</p>
<span id="more"></span>
<hr>
<blockquote>
<p>会话管理</p>
</blockquote>
<p>Session是保存在服务端的一份数据通常保存在(Tomcat, Jetty)等Web容器中，如果我们的应用实例复制多份以集群方式部署在不同的服务器上，那么请求经过负载均衡后选择服务端访问就会出现已经登录了但session不在此节点而在其他节点的情况。解决办法有tomcat做session复制，负载均衡使用IP_Hash策略，把session作为外部公共资源来存储等。</p>
<p>其他的没实践过只说说最后一种，把session作为外部公共资源来存储，那么一定是一块可以被大家都访问到的内存空间，通常选用Redis,MongoDB等数据库来存储session信息，我们可以充分利用Redis的kv存储方式，读取速度，主从数据同步特点来保证方便安全的使用session机制。</p>
<hr>
<h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><p>Spring session帮我们做了从web容器中将session剥离存放到自定义的介质中提供了一系列session管理的API</p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221125231631.png"><br>spring-session分为以下核心模块：</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/30/hello-world/</url>
    <content><![CDATA[<h1 id="中文测试"><a href="#中文测试" class="headerlink" title="中文测试"></a>中文测试</h1><h2 id="Linux操作系统中的基础概念"><a href="#Linux操作系统中的基础概念" class="headerlink" title="Linux操作系统中的基础概念"></a>Linux操作系统中的基础概念</h2><p>在介绍select、poll、epoll之前，我们首先了解一下linux的基础概念</p>
<h3 id="用户空间-x2F-内核空间"><a href="#用户空间-x2F-内核空间" class="headerlink" title="用户空间&#x2F;内核空间"></a>用户空间&#x2F;内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2^32）</p>
<p>而操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（Kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分是内核空间，一部分是用户空间。</p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且经常切换是非常耗费资源的。</p>
<h1 id="英文测试"><a href="#英文测试" class="headerlink" title="英文测试"></a>英文测试</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h1><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/2022-07-29_094240.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/feynman.png"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用注解来做鉴权</title>
    <url>/2022/12/09/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9D%A5%E5%81%9A%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>场景是这样的最近写的菜谱应用，设计成可以允许不登录使用检索功能，但是想要收藏菜谱就必须要登录，正常编写拦截器的拦截和放行规则即可，但突然想到之前阅读大佬源码的时候他用了自定义注解的方式，感觉挺优雅o(￣▽￣)ｄ，所以我也想这样写试试。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h3><p>在讨论HandlerMethod之前先捋一下请求被处理的过程<br>request -&gt; DispatcherServlet -&gt; HandlerMapping -&gt; HandlerAdapter -&gt; ….视图相关组件</p>
<p>各组件功能的概述：</p>
<ul>
<li><p>DispatcherServlet：spring mvc的大脑，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，<u>DispatcherServlet作为统一访问点，进行全局的流程控制</u></p>
</li>
<li><p>HandlerMapping：HandlerMapping 叫做处理器映射器，它的作用就是<u>根据当前 request 找到对应的 Handler 和 Interceptor，然后封装成一个 HandlerExecutionChain 对象返回</u></p>
</li>
<li><p>HandlerAdapter：HandlerAdapter 负责完成<u>上一步返回的handler的动态调用进行请求的处理</u>以及生成ModelAndView</p>
</li>
</ul>
<p>上文说到HandlerMapping会对请求做处理，在这些处理中其中一个环节是对<strong>请求匹配条</strong>件和<strong>控制器方法</strong>提取出来形成&lt;K,V&gt;的<strong>映射关系</strong>，而这里的value控制器方法就是今天的主角HandlerMethod封装后的结果</p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209145934.png"></p>
<p>可以看到封装的有request实际作用的控制器bean，beanType，实际调用的method等等，那么我们就可以通过判断该请求调用的方法是否存在注解来作为拦截器通过条件的之一，完整的思路如下。</p>
<p>拦截请求后，首先获取对用controller中调用的method，判断method是否有注解，如果没有那么就代表该请求不需要被权限校验，直接被放行，如果存在则进行后续鉴权的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">if</span> (!supports(handler)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">HandlerMethod</span> <span class="variable">method</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">       <span class="type">Login</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getMethodAnnotation(Login.class);</span><br><span class="line">       <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       log.info(<span class="string">&quot;通过登录权限校验的方法: &quot;</span>+ method.getMethod().getDeclaringClass()+<span class="string">&quot; =&gt; &quot;</span>+method.getMethod().getName());</span><br><span class="line">       <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">       <span class="keyword">if</span> (session.getAttribute(Constant.SESSION) == <span class="literal">null</span>) &#123;</span><br><span class="line">           response.sendRedirect(<span class="string">&quot;http://localhost:8080/login/gitee&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209151035.png"></p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209152152.png"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
