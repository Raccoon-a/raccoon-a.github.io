<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/30/hello-world/</url>
    <content><![CDATA[<h1 id="中文测试"><a href="#中文测试" class="headerlink" title="中文测试"></a>中文测试</h1><h2 id="Linux操作系统中的基础概念"><a href="#Linux操作系统中的基础概念" class="headerlink" title="Linux操作系统中的基础概念"></a>Linux操作系统中的基础概念</h2><p>在介绍select、poll、epoll之前，我们首先了解一下linux的基础概念</p>
<h3 id="用户空间-x2F-内核空间"><a href="#用户空间-x2F-内核空间" class="headerlink" title="用户空间&#x2F;内核空间"></a>用户空间&#x2F;内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2^32）</p>
<p>而操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（Kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分是内核空间，一部分是用户空间。</p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且经常切换是非常耗费资源的。</p>
<h1 id="英文测试"><a href="#英文测试" class="headerlink" title="英文测试"></a>英文测试</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h1><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/2022-07-29_094240.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/feynman.png"></p>
]]></content>
  </entry>
  <entry>
    <title>0分布式系统原理</title>
    <url>/2022/12/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h3><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统</p>
<h3 id="为什么需要分布式系统"><a href="#为什么需要分布式系统" class="headerlink" title="为什么需要分布式系统"></a>为什么需要分布式系统</h3><p>为了解决单体应用，集中式架构的性能瓶颈，例如服务端的计算，存储的压力，单点故障使整个系统不可用等等。。</p>
<h3 id="分布式系统的特点"><a href="#分布式系统的特点" class="headerlink" title="分布式系统的特点"></a>分布式系统的特点</h3><p>核心是 <font class="redc"><strong>可扩展性</strong></font>，通过对服务，存储的扩展，来提高系统的处理能力。</p>
<span id="more"></span>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221215095254.png"></p>
<ul>
<li><p>一致性：<strong>所有节点同时看到相同的数据</strong>，即更新数据操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p>
</li>
<li><p>可用性: <strong>任何时候，读写都是成功的</strong>，每次向未崩溃的节点发送请求，总能保证收到响应数据。</p>
</li>
<li><p>分区容忍性: <strong>当部分节点出现消息丢失或分区故障时，系统仍然能够继续运行</strong>，即系统容忍网站出现分区行为，且遇到某节点情况，或分区网络之间不可达情况下，仍能对外提供一致性和可用性服务。</p>
</li>
</ul>
<div class="note success"><p> <font class="big"> <strong>什么是分区？</strong></font><br>在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域，这就是分区。</p>
</div>

<h4 id="CAP不可同时满足（反证法）"><a href="#CAP不可同时满足（反证法）" class="headerlink" title="CAP不可同时满足（反证法）"></a>CAP不可同时满足（反证法）</h4><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221215112907.png"></p>
<p>常见CP架构的Zookeeper，AP架构的Eureka</p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Session</title>
    <url>/2022/11/25/Session/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Cookie-Session-Token"><a href="#Cookie-Session-Token" class="headerlink" title="Cookie, Session, Token"></a>Cookie, Session, Token</h3><p>Cookie： <del>小饼干</del>，是保存在客户端的一小份数据(不允许超过4KB)<br>Session： 术语叫会话控制，是一种在客户端与服务端之间保持状态的解决方案，通常会在服务端的一份数据来记录会话状态<br>Token：令牌，是校验的凭证，可以理解为cookie中存的session id亦或是存在localstorage中的jwt字符串</p>
<div class="note success"><p> Q：为什么我们登录过一次之后下一次再访问就不需要登录了？<br>A：通常在应用层HTTP都是作为无状态协议，每个请求都是完全独立且每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更，那么解决上述问题的通用流程如下：</p>
</div>
<span id="more"></span>
<p>(1)首次登录：客户端发送请求携带登录信息访问服务端<br>(2)颁发令牌：服务端校验用户账户密码正确后返回客户端一个令牌(Token)<br>(3)再次访问：客户端把Token保存在(Cookie, LoaclStroage)等地方以后的每次请求都携带此令牌</p>
<p>目前比较常用的方式有Cookie-Session, JWT这两种方式都是满足上述的通用流程但又有莫大的差别概述如下</p>
<p>Cookie-Session(有状态):<br>(1)客户端发送请求携带登录信息访问服务端。<br>(2)服务端校验用户账户密码正确后，会在服务端新建一份session同时把session的id返回给客户端一般保存在cookie中。<br>(3)以后的每次请求都会携带cookie中的token信息(session Id)和服务端保存的session做校验。</p>
<p>JSON-Web-Token(去中心化)<br>(1)客户端发送请求携带登录信息访问服务端。<br>(2)服务端校验用户账户密码正确后，会对用户信息，签发时间，过期时间加密生成一段字符串返回给客户端一般保存在LocalStorage中。<br>(3)以后的每次请求都会在headers的Authorization中携带token信息送给服务端解析校验。</p>
<div class="note warning"><p>讨论上述两种方案是否有无状态可以用另外一个角度思考，session方案是可以通过服务端删除session来使用户退出登录(结束维持的状态)，而jwt方案的权限有效时间是根据颁发时就决定的，无法在服务端主动使token失效，由此就可以看出这并不是和服务端之间持续的维持状态 </p>
</div>

<hr>
<blockquote>
<p>会话管理</p>
</blockquote>
<p>Session是保存在服务端的一份数据通常保存在(Tomcat, Jetty)等Web容器中，如果我们的应用实例复制多份以集群方式部署在不同的服务器上，那么请求经过负载均衡后选择服务端访问就会出现已经登录了但session不在此节点而在其他节点的情况。解决办法有tomcat做session复制，负载均衡使用IP_Hash策略，把session作为外部公共资源来存储等。</p>
<p>其他的没实践过只说说最后一种，把session作为外部公共资源来存储，那么一定是一块可以被大家都访问到的内存空间，通常选用Redis,MongoDB等数据库来存储session信息，我们可以充分利用Redis的kv存储方式，读取速度，主从数据同步特点来保证方便安全的使用session机制。</p>
<hr>
<h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><p>Spring session帮我们做了从web容器中将session剥离存放到自定义的介质中提供了一系列session管理的API</p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221125231631.png"><br>spring-session分为以下核心模块：</p>
]]></content>
  </entry>
  <entry>
    <title>使用注解来做鉴权</title>
    <url>/2022/12/09/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9D%A5%E5%81%9A%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>场景是这样的最近写的菜谱应用，设计成可以允许不登录使用检索功能，但是想要收藏菜谱就必须要登录，正常编写拦截器的拦截和放行规则即可，但突然想到之前阅读大佬项目的时候他用了自定义注解的方式，感觉挺优雅o(￣▽￣)ｄ，所以我也想这样写试试</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h3><p>在讨论HandlerMethod之前先捋一下请求被处理的过程<br>request -&gt; DispatcherServlet -&gt; HandlerMapping -&gt; HandlerAdapter -&gt; ….视图相关组件</p>
<span id="more"></span>
<p>各组件功能的概述：</p>
<ul>
<li><p>DispatcherServlet：spring mvc的大脑，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，<u>DispatcherServlet作为统一访问点，进行全局的流程控制</u></p>
</li>
<li><p>HandlerMapping：HandlerMapping 叫做处理器映射器，它的作用就是<u>根据当前 request 找到对应的 Handler 和 Interceptor，然后封装成一个 HandlerExecutionChain 对象返回</u></p>
</li>
<li><p>HandlerAdapter：HandlerAdapter 负责完成<u>上一步返回的handler的动态调用进行请求的处理</u>以及生成ModelAndView</p>
</li>
</ul>
<p>上文说到HandlerMapping会对请求做处理，在这些处理中其中一个环节是对<strong>请求匹配条</strong>件和<strong>控制器方法</strong>提取出来形成&lt;K,V&gt;的<strong>映射关系</strong>，而这里的value控制器方法就是今天的主角HandlerMethod封装后的结果</p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209145934.png"></p>
<p>可以看到封装的有request实际作用的控制器bean，beanType，实际调用的method等等，那么我们就可以通过判断该请求调用的方法是否存在注解来作为拦截器通过条件的之一，完整的思路如下。</p>
<p>拦截请求后，首先获取对用controller中调用的method，判断method是否有注解，如果没有那么就代表该请求不需要被权限校验，直接被放行，如果存在则进行后续鉴权的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="keyword">if</span> (!supports(handler)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">HandlerMethod</span> <span class="variable">method</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">       <span class="type">Login</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getMethodAnnotation(Login.class);</span><br><span class="line">       <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       log.info(<span class="string">&quot;通过登录权限校验的方法: &quot;</span>+ method.getMethod().getDeclaringClass()+<span class="string">&quot; =&gt; &quot;</span>+method.getMethod().getName());</span><br><span class="line">       <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">       <span class="keyword">if</span> (session.getAttribute(Constant.SESSION) == <span class="literal">null</span>) &#123;</span><br><span class="line">           response.sendRedirect(<span class="string">&quot;http://localhost:8080/login/gitee&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209151035.png"></p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209152152.png"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
