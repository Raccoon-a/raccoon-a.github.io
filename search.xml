<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>会话管理</title>
    <url>/2022/11/25/Session/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Cookie-Session-Token"><a href="#Cookie-Session-Token" class="headerlink" title="Cookie, Session, Token"></a>Cookie, Session, Token</h3><p>Cookie： <del>小饼干</del>，是保存在客户端的一小份数据(不允许超过4KB)<br>Session： 术语叫会话控制，是一种在客户端与服务端之间保持状态的解决方案，通常会在服务端的一份数据来记录会话状态<br>Token：令牌，是校验的凭证，可以理解为cookie中存的session id亦或是存在localstorage中的jwt字符串</p>
<div class="note success"><p> Q：为什么我们登录过一次之后下一次再访问就不需要登录了？<br>A：通常在应用层HTTP都是作为无状态协议，每个请求都是完全独立且每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更，那么解决上述问题的通用流程如下：</p>
</div>
<span id="more"></span>
<p>(1)首次登录：客户端发送请求携带登录信息访问服务端<br>(2)颁发令牌：服务端校验用户账户密码正确后返回客户端一个令牌(Token)<br>(3)再次访问：客户端把Token保存在(Cookie, LoaclStroage)等地方以后的每次请求都携带此令牌</p>
<p>目前比较常用的方式有Cookie-Session, JWT这两种方式都是满足上述的通用流程但又有莫大的差别概述如下</p>
<p>Cookie-Session(特点：有状态):<br>(1)客户端发送请求携带登录信息访问服务端。<br>(2)服务端校验用户账户密码正确后，会在服务端新建一份session同时把session的id返回给客户端一般保存在cookie中。<br>(3)以后的每次请求都会携带cookie中的token信息(session Id)和服务端保存的session做校验。</p>
<p>JSON-Web-Token(特点：去中心化)<br>(1)客户端发送请求携带登录信息访问服务端。<br>(2)服务端校验用户账户密码正确后，会对用户信息，签发时间，过期时间加密生成一段字符串返回给客户端一般保存在LocalStorage中。<br>(3)以后的每次请求都会在headers的Authorization中携带token信息送给服务端解析校验。</p>
<div class="note warning"><p>讨论上述两种方案是否有无状态可以用另外一个角度思考，session方案是可以通过服务端删除session来使用户退出登录(结束维持的状态)，而jwt方案的权限有效时间是根据颁发时就决定的，无法在服务端主动使token失效，由此就可以看出这并不是和服务端之间持续的维持状态 </p>
</div>

<hr>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>Session是保存在服务端的一份数据通常保存在(Tomcat, Jetty)等Web容器中，如果我们的应用实例复制多份以集群方式部署在不同的服务器上，那么请求经过负载均衡后选择服务端访问就会出现已经登录了但session不在此节点而在其他节点的情况。解决办法有tomcat做session复制，负载均衡使用IP_Hash策略，把session作为外部公共资源来存储等。</p>
<p>其他的没实践过只说说最后一种，把session作为外部公共资源来存储，那么一定是一块可以被大家都访问到的内存空间，存储方式通常选用Redis,MongoDB等数据库来存储session信息，我们可以充分利用Redis的kv存储方式，读取速度，主从数据同步特点来保证便捷的使用session机制。</p>
<h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><p>Spring Session是Spring系列提供的会话管理API，它允许以应用外部容器中立的方式替换HttpSession，也就是说它是将tomcat等web容器中的session抽离出来存放进自定义容器中。<br>详细介绍：<a href="https://docs.spring.io/spring-session/reference/index.html">https://docs.spring.io/spring-session/reference/index.html</a></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>session远优于的</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/30/hello-world/</url>
    <content><![CDATA[<h1 id="中文测试"><a href="#中文测试" class="headerlink" title="中文测试"></a>中文测试</h1><h2 id="Linux操作系统中的基础概念"><a href="#Linux操作系统中的基础概念" class="headerlink" title="Linux操作系统中的基础概念"></a>Linux操作系统中的基础概念</h2><p>在介绍select、poll、epoll之前，我们首先了解一下linux的基础概念</p>
<h3 id="用户空间-x2F-内核空间"><a href="#用户空间-x2F-内核空间" class="headerlink" title="用户空间&#x2F;内核空间"></a>用户空间&#x2F;内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2^32）</p>
<p>而操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（Kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分是内核空间，一部分是用户空间。</p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且经常切换是非常耗费资源的。</p>
<h1 id="英文测试"><a href="#英文测试" class="headerlink" title="英文测试"></a>英文测试</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h1><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/2022-07-29_094240.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/feynman.png"></p>
]]></content>
  </entry>
  <entry>
    <title>0分布式系统原理</title>
    <url>/2022/12/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h2><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统</p>
<h2 id="为什么需要分布式系统"><a href="#为什么需要分布式系统" class="headerlink" title="为什么需要分布式系统"></a>为什么需要分布式系统</h2><p>为了解决单体应用，集中式架构的性能瓶颈，例如服务端的计算，存储的压力，单点故障使整个系统不可用等等。。</p>
<h2 id="分布式系统的特点"><a href="#分布式系统的特点" class="headerlink" title="分布式系统的特点"></a>分布式系统的特点</h2><p>核心是 <font class="redc"><strong>可扩展性</strong></font>，通过对服务，存储的扩展，来提高系统的处理能力。</p>
<span id="more"></span>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221215095254.png"></p>
<p>[1] 一致性：<font class="redc">所有节点同时看到相同的数据</font>，即更新数据操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p>
<p>[2] 可用性: <font class="redc">任何时候，读写都是成功的</font>，每次向未崩溃的节点发送请求，总能保证收到响应数据。</p>
<p>[3] 分区容错性: <font class="redc">当部分节点出现消息丢失或分区故障时，系统仍然能够继续运行</font>，即系统容忍网站出现分区行为，且遇到某节点情况，或分区网络之间不可达情况下，仍能对外提供一致性和可用性服务。 </p>
<div class="note success"><p> <font class="big"> <strong>什么是分区？</strong></font><br>在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域，这就是分区。</p>
</div>

<h3 id="CAP不可同时满足（反证法）"><a href="#CAP不可同时满足（反证法）" class="headerlink" title="CAP不可同时满足（反证法）"></a>CAP不可同时满足（反证法）</h3><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221215112907.png"></p>
<p>常见CP架构的Zookeeper，AP架构的Eureka</p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用注解来做鉴权</title>
    <url>/2022/12/09/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9D%A5%E5%81%9A%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>场景是这样的最近写的菜谱应用，设计成可以允许不登录使用检索功能，但是想要收藏菜谱就必须要登录，正常编写拦截器的拦截和放行规则即可，但突然想到之前阅读大佬项目的时候他用了自定义注解的方式，感觉挺优雅o(￣▽￣)ｄ，所以我也想这样写试试</p>
<h2 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h2><span id="more"></span>


<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209145934.png"></p>
<p>可以看到封装的有request实际作用的控制器bean，beanType，实际调用的method等等，那么我们就可以通过判断该请求调用的方法是否存在注解来作为拦截器通过条件的之一，完整的思路如下。</p>
<p>拦截请求后，首先获取对用controller中调用的method，判断method是否有注解，如果没有那么就代表该请求不需要被权限校验，直接被放行，如果存在则进行后续鉴权的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HandlerMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!supports(handler)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">method</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">    <span class="type">Login</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getMethodAnnotation(Login.class);</span><br><span class="line">    <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;通过登录权限校验的方法: &quot;</span>+ method.getMethod().getDeclaringClass()+<span class="string">&quot; =&gt; &quot;</span>+method.getMethod().getName());</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">    <span class="keyword">if</span> (session.getAttribute(Constant.SESSION) == <span class="literal">null</span>) &#123;</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;http://localhost:8080/login/gitee&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209151035.png"></p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209152152.png"></p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2> <div class="note success"><p>[1]<br> 需要注意的是第一步handler类型的判断，这里一定要判断一次，因为有时候未必就一定是HandlerMethod类型，当我们访问非controller处理的请求时会抛类型转换的异常，例如访问没有配置路由的127.0.0.1:8080或resource目录下的静态资源
 </p>
</div>
<p> <img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221217232921.png">Stackoverflow的参考：<a href="https://stackoverflow.com/questions/17575623/in-a-spring-mvc-interceptor-how-can-i-access-to-the-handler-controller-method">https://stackoverflow.com/questions/17575623/</a></p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221217233306.png"></p>
<div class="note success"><p>[2]<br>关于第三个Object handler到底是什么，StackOverflow上也有解释，其实controller就是属于handler(处理程序)的一种，但handler未必是controller，而在SpringMvc拦截器中handler就是指controller</p>
</div>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221217235452.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221218001052.png"></p>
<div class="note success"><p>[3]<br>bridgedMethod这个参数，在初识HandlerMethod的时候非常疑惑，其他的看单词都能猜个大概但唯独这个，实际上它代表的是<font class='redc'>被桥接的原方法(bridged 而不是 bridge)</font></p>
</div>
<p>于是又去补了下桥接方法的知识，这里找了很多文章，博客看，以下是简述那么什么是(bridgeMethod)桥接方法？ </p>
<h3 id="什么时候会出现桥接方法？"><a href="#什么时候会出现桥接方法？" class="headerlink" title="什么时候会出现桥接方法？"></a>什么时候会出现桥接方法？</h3><p>[1]子类重写父类方法时类型不一致<br>[2]子类重写父类带有泛型的方法</p>
<h3 id="为什么出现桥接方法"><a href="#为什么出现桥接方法" class="headerlink" title="为什么出现桥接方法"></a>为什么出现桥接方法</h3><p>在.java被编译为.class文件加载进jvm后，jvm判断子类继承父类的方法是否为重写时<font class='redc'>会要求方法签名必须一致</font>，而Java在语义层面对于重写的定义只是要求方法的返回值类型相同就行了(去掉@Override注解自动检查的情况)，因为这二者的差异才出现编译器自动生成桥接方法来保证jvm层面正确的执行</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
