<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Netty_class_0</title>
    <url>/2022/09/06/Netty-class-0/</url>
    <content><![CDATA[<h2 id="0-Netty简单实现TCP服务"><a href="#0-Netty简单实现TCP服务" class="headerlink" title="[0] Netty简单实现TCP服务"></a>[0] Netty简单实现TCP服务</h2><h3 id="服务端引导程序"><a href="#服务端引导程序" class="headerlink" title="服务端引导程序"></a>服务端引导程序</h3><span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认线程数cpu核心数*2</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">NettyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            future.addListener(<span class="keyword">new</span> <span class="title class_">StateHandler</span>());</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="服务端消息处理程序"><a href="#服务端消息处理程序" class="headerlink" title="服务端消息处理程序"></a>服务端消息处理程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址:&quot;</span> + channel.remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, 客户端(つд⊂)&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端引导程序"><a href="#客户端引导程序" class="headerlink" title="客户端引导程序"></a>客户端引导程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(workGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">NettyClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            future.addListener(<span class="keyword">new</span> <span class="title class_">StateHandler</span>());</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端消息处理程序"><a href="#客户端消息处理程序" class="headerlink" title="客户端消息处理程序"></a>客户端消息处理程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello, server: (,,・ω・,,)&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        cause.getStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-Netty使用Http协议"><a href="#1-Netty使用Http协议" class="headerlink" title="[1] Netty使用Http协议"></a>[1] Netty使用Http协议</h2><h3 id="服务端引导程序-1"><a href="#服务端引导程序-1" class="headerlink" title="服务端引导程序"></a>服务端引导程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>()).addLast(<span class="keyword">new</span> <span class="title class_">HttpServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务端消息处理程序-1"><a href="#服务端消息处理程序-1" class="headerlink" title="服务端消息处理程序"></a>服务端消息处理程序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpObject&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpRequest) msg;</span><br><span class="line">            System.out.println(<span class="string">&quot;uri =&gt; &quot;</span> + request.uri());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">content</span> <span class="operator">=</span> Unpooled.copiedBuffer(<span class="string">&quot;hello 我是 http server&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultFullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Netty_class_1</title>
    <url>/2022/09/08/Netty-class-1/</url>
    <content><![CDATA[<h2 id="0-Netty核心组件及模块介绍"><a href="#0-Netty核心组件及模块介绍" class="headerlink" title="[0] Netty核心组件及模块介绍"></a>[0] Netty核心组件及模块介绍</h2><p>参考链接：<br>[1]: <a href="https://waylau.gitbooks.io/netty-4-user-guide/content/Architectural-Overview/Rich-Buffer-Data-Structure.html">Netty 4.x User Guide 中文翻译《Netty 4.x 用户指南》</a><br>[2]: <a href="https://macondo.gitbook.io/macondo/">Netty in Action 翻译与学习</a></p>
<span id="more"></span>

<h2 id="1-Bootstrap、ServerBootstrap"><a href="#1-Bootstrap、ServerBootstrap" class="headerlink" title="[1] Bootstrap、ServerBootstrap"></a>[1] Bootstrap、ServerBootstrap</h2><p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类<br>常见的方法有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServerBootstrap <span class="title function_">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span>，该方法用于服务器端，用来设置两个 EventLoop</span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">group</span><span class="params">(EventLoopGroup group)</span>，该方法用于客户端，用来设置一个 EventLoop</span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span>，该方法用来设置一个服务器端的通道实现</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; B <span class="title function_">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span>，用来给 ServerChannel 添加配置</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ServerBootstrap <span class="title function_">childOption</span><span class="params">(ChannelOption&lt;T&gt; childOption, T value)</span>，用来给接收到的通道添加配置</span><br><span class="line"><span class="keyword">public</span> ServerBootstrap <span class="title function_">childHandler</span><span class="params">(ChannelHandler childHandler)</span>，该方法用来设置业务处理类（自定义的handler）</span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">bind</span><span class="params">(<span class="type">int</span> inetPort)</span>，该方法用于服务器端，用来设置占用的端口号</span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(String inetHost, <span class="type">int</span> inetPort)</span>，该方法用于客户端，用来连接服务器端</span><br></pre></td></tr></table></figure>
<h2 id="2-Future、ChannelFuture"><a href="#2-Future、ChannelFuture" class="headerlink" title="[2] Future、ChannelFuture"></a>[2] Future、ChannelFuture</h2><p>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件<br>常见的方法有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Channel <span class="title function_">channel</span><span class="params">()</span>，返回当前正在进行 IO 操作的通道</span><br><span class="line">ChannelFuture <span class="title function_">sync</span><span class="params">()</span>，等待异步操作执行完毕</span><br></pre></td></tr></table></figure>
<h2 id="3-Channel"><a href="#3-Channel" class="headerlink" title="[3] Channel"></a>[3] Channel</h2><p>Netty 网络通信的组件，能够用于执行网络 I&#x2F;O 操作。<br>通过 Channel 可获得当前网络连接的通道的状态<br>通过 Channel 可获得网络连接的配置参数（例如接收缓冲区大小）<br><font class='redc'>Channel 提供异步的网络 I&#x2F;O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I&#x2F;O 调用都将立即返回，并且不保证在调用结束时所请求的 I&#x2F;O 操作已完成</font><br>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I&#x2F;O 操作成功、失败或取消时回调通知调用方<br>支持关联 I&#x2F;O 操作与对应的处理程序<br>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NioSocketChannel，异步的客户端 TCP Socket 连接。</span><br><span class="line">NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</span><br><span class="line">NioDatagramChannel，异步的 UDP 连接。</span><br><span class="line">NioSctpChannel，异步的客户端 Sctp 连接。</span><br><span class="line">NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</span><br></pre></td></tr></table></figure>

<h2 id="4-ChannelHandler"><a href="#4-ChannelHandler" class="headerlink" title="[4] ChannelHandler"></a>[4] ChannelHandler</h2><p>ChannelHandler 是一个接口，处理 I&#x2F;O 事件或拦截 I&#x2F;O 操作，并将其转发到其 ChannelPipeline（业务处理链）中的下一个处理程序<br>详细API参考：<a href="https://doc.yonyoucloud.com/doc/essential-netty-in-action/CORE%20FUNCTIONS/The%20ChannelHandler%20Family.html">ChannelHandler 和 ChannelPipeline</a></p>
<h2 id="5-Pipeline、ChannelPipeline"><a href="#5-Pipeline、ChannelPipeline" class="headerlink" title="[5] Pipeline、ChannelPipeline"></a>[5] Pipeline、ChannelPipeline</h2><p>ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链</p>
<div class="note warning"><p>也可以这样理解：ChannelPipeline 是保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作</p>
</div>
<p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互<br>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelPipeline <span class="title function_">addFirst</span><span class="params">(ChannelHandler... handlers)</span> 把一个业务处理类（handler）添加到链中的第一个位置</span><br><span class="line">ChannelPipeline <span class="title function_">addLast</span><span class="params">(ChannelHandler... handlers)</span> 把一个业务处理类（handler）添加到链中的最后一个位置</span><br></pre></td></tr></table></figure>

<h2 id="6-ChannelHandlerContext"><a href="#6-ChannelHandlerContext" class="headerlink" title="[6]  ChannelHandlerContext"></a>[6]  ChannelHandlerContext</h2><p>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象<br>即 ChannelHandlerContext 中包含一个具体的事件处理器 ChannelHandler，同时 ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用。<br>常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture <span class="title function_">close</span><span class="params">()</span>，关闭通道</span><br><span class="line">ChannelOutboundInvoker <span class="title function_">flush</span><span class="params">()</span>，刷新</span><br><span class="line">ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span>，将数据写到ChannelPipeline 中当前 ChannelHandler 的下一个 ChannelHandler 开始处理（出站）</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>0分布式系统原理</title>
    <url>/2022/12/15/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h2><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统</p>
<h2 id="为什么需要分布式系统"><a href="#为什么需要分布式系统" class="headerlink" title="为什么需要分布式系统"></a>为什么需要分布式系统</h2><p>为了解决单体应用，集中式架构的性能瓶颈，例如服务端的计算，存储的压力，单点故障使整个系统不可用等等。。</p>
<h2 id="分布式系统的特点"><a href="#分布式系统的特点" class="headerlink" title="分布式系统的特点"></a>分布式系统的特点</h2><p>核心是 <font class="redc"><strong>可扩展性</strong></font>，通过对服务，存储的扩展，来提高系统的处理能力。</p>
<span id="more"></span>
<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221215095254.png"></p>
<p>[1] 一致性：<font class="redc">所有节点同时看到相同的数据</font>，即更新数据操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p>
<p>[2] 可用性: <font class="redc">任何时候，读写都是成功的</font>，每次向未崩溃的节点发送请求，总能保证收到响应数据。</p>
<p>[3] 分区容错性: <font class="redc">当部分节点出现消息丢失或分区故障时，系统仍然能够继续运行</font>，即系统容忍网站出现分区行为，且遇到某节点情况，或分区网络之间不可达情况下，仍能对外提供一致性和可用性服务。 </p>
<div class="note success"><p> <font class="big"> <strong>什么是分区？</strong></font><br>在分布式系统中，不同的节点分布在不同的子网络中，由于一些特殊的原因，这些子节点之间出现了网络不通的状态，但他们的内部子网络是正常的。从而导致了整个系统的环境被切分成了若干个孤立的区域，这就是分区。</p>
</div>

<h3 id="CAP不可同时满足（反证法）"><a href="#CAP不可同时满足（反证法）" class="headerlink" title="CAP不可同时满足（反证法）"></a>CAP不可同时满足（反证法）</h3><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221215112907.png"></p>
<p>常见CP架构的Zookeeper，AP架构的Eureka</p>
]]></content>
      <categories>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/09/hello-world/</url>
    <content><![CDATA[<h1 id="中文测试"><a href="#中文测试" class="headerlink" title="中文测试"></a>中文测试</h1><h2 id="Linux操作系统中的基础概念"><a href="#Linux操作系统中的基础概念" class="headerlink" title="Linux操作系统中的基础概念"></a>Linux操作系统中的基础概念</h2><p>在介绍select、poll、epoll之前，我们首先了解一下linux的基础概念</p>
<h3 id="用户空间-x2F-内核空间"><a href="#用户空间-x2F-内核空间" class="headerlink" title="用户空间&#x2F;内核空间"></a>用户空间&#x2F;内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2^32）</p>
<p>而操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（Kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分是内核空间，一部分是用户空间。</p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且经常切换是非常耗费资源的。</p>
<h1 id="英文测试"><a href="#英文测试" class="headerlink" title="英文测试"></a>英文测试</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h1><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/2022-07-29_094240.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/feynman.png"></p>
]]></content>
  </entry>
  <entry>
    <title>使用注解来做鉴权</title>
    <url>/2022/12/09/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9D%A5%E5%81%9A%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>场景是这样的最近写的菜谱应用，设计成可以允许不登录使用检索功能，但是想要收藏菜谱就必须要登录，正常编写拦截器的拦截和放行规则即可，但突然想到之前阅读大佬项目的时候他用了自定义注解的方式，感觉挺优雅o(￣▽￣)ｄ，所以我也想这样写试试</p>
<h2 id="HandlerMethod"><a href="#HandlerMethod" class="headerlink" title="HandlerMethod"></a>HandlerMethod</h2><span id="more"></span>


<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209145934.png"></p>
<p>可以看到封装的有request实际作用的控制器bean，beanType，实际调用的method等等，那么我们就可以通过判断该请求调用的方法是否存在注解来作为拦截器通过条件的之一，完整的思路如下。</p>
<p>拦截请求后，首先获取对用controller中调用的method，判断method是否有注解，如果没有那么就代表该请求不需要被权限校验，直接被放行，如果存在则进行后续鉴权的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HandlerMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!supports(handler)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">method</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line">    <span class="type">Login</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getMethodAnnotation(Login.class);</span><br><span class="line">    <span class="keyword">if</span> (annotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;通过登录权限校验的方法: &quot;</span>+ method.getMethod().getDeclaringClass()+<span class="string">&quot; =&gt; &quot;</span>+method.getMethod().getName());</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">    <span class="keyword">if</span> (session.getAttribute(Constant.SESSION) == <span class="literal">null</span>) &#123;</span><br><span class="line">        response.sendRedirect(<span class="string">&quot;http://localhost:8080/login/gitee&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209151035.png"></p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221209152152.png"></p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2> <div class="note success"><p>[1]<br> 需要注意的是第一步handler类型的判断，这里一定要判断一次，因为有时候未必就一定是HandlerMethod类型，当我们访问非controller处理的请求时会抛类型转换的异常，例如访问没有配置路由的127.0.0.1:8080或resource目录下的静态资源
 </p>
</div>
<p> <img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221217232921.png">Stackoverflow的参考：<a href="https://stackoverflow.com/questions/17575623/in-a-spring-mvc-interceptor-how-can-i-access-to-the-handler-controller-method">https://stackoverflow.com/questions/17575623/</a></p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221217233306.png"></p>
<div class="note success"><p>[2]<br>关于第三个Object handler到底是什么，StackOverflow上也有解释，其实controller就是属于handler(处理程序)的一种，但handler未必是controller，而在SpringMvc拦截器中handler就是指controller</p>
</div>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221217235452.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20221218001052.png"></p>
<div class="note success"><p>[3]<br>bridgedMethod这个参数，在初识HandlerMethod的时候非常疑惑，其他的看单词都能猜个大概但唯独这个，实际上它代表的是<font class='redc'>被桥接的原方法(bridged 而不是 bridge)</font></p>
</div>
<p>于是又去补了下桥接方法的知识，这里找了很多文章，博客看，以下是简述那么什么是(bridgeMethod)桥接方法？ </p>
<h3 id="什么时候会出现桥接方法？"><a href="#什么时候会出现桥接方法？" class="headerlink" title="什么时候会出现桥接方法？"></a>什么时候会出现桥接方法？</h3><p>[1]子类重写父类方法时类型不一致<br>[2]子类重写父类带有泛型的方法</p>
<h3 id="为什么出现桥接方法"><a href="#为什么出现桥接方法" class="headerlink" title="为什么出现桥接方法"></a>为什么出现桥接方法</h3><p>在.java被编译为.class文件加载进jvm后，jvm判断子类继承父类的方法是否为重写时<font class='redc'>会要求方法签名必须一致</font>，而Java在语义层面对于重写的定义只是要求方法的返回值类型相同就行了(去掉@Override注解自动检查的情况)，因为这二者的差异才出现编译器自动生成桥接方法来保证jvm层面正确的执行</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>封装一个springboot-stater</title>
    <url>/2022/11/01/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAspringboot-stater/</url>
    <content><![CDATA[<h2 id="0-简述自动装配原理"><a href="#0-简述自动装配原理" class="headerlink" title="[0] 简述自动装配原理"></a>[0] 简述自动装配原理</h2><p>在springboot的核心注解@SpringBootApplication里包含一个名为@EnableAutoConfiguration的注解，这是执行自动装配的关键，而在@EnableAutoConfiguration注解中实际执行自动装配 的是AutoConfigurationImportSelector类,该类的getAutoConfigurationEntry方法调用getCandidateConfigurations方法<font class='redc'>扫描resource目录下META-INF&#x2F;spring.factories文件返回需要被加载进IOC容器的配置类列表</font><span id="more"></span><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173009.png"><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173100.png"><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173202.png"><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173228.png"></p>
<div class="note success"><p>总结:<br>springboot自动装配是因为在启动类上存在@EnableAutoConfiguration注解，所以在启动时会扫描被引用starter的jar包下META-INF&#x2F;spring.factories文件，把里面声明的自动配置类加载进IOC容器中</p>
</div>

<h2 id="1-封装spring-boot-starter"><a href="#1-封装spring-boot-starter" class="headerlink" title="[1] 封装spring-boot-starter"></a>[1] 封装spring-boot-starter</h2><p>POM文件中写好该starter信息，</p>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173402.png"><br>在resource&#x2F;META-INF下新建spring.factories文件里面写上自动配置类的全限定类名(包路径+类名)，然后在当前项目的子模块中就可以了引用了<br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173432.png">或者使用maven打包后转存至本地maven仓库可以在其他项目中引用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=&#123;&#125; -DgroupId=&#123;&#125; -DartifactId=&#123;&#125; -Dversion=&#123;&#125; -Dpackaging=&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-关于RPC基于注解的服务自动注册，发现"><a href="#3-关于RPC基于注解的服务自动注册，发现" class="headerlink" title="[3] 关于RPC基于注解的服务自动注册，发现"></a>[3] 关于RPC基于注解的服务自动注册，发现</h2><p>BeanPostProcessor类是IOC容器对外提供的扩展接口，内部有两个方法<br>bean 初始化前的处理： postProcessBeforeInitialization<br>bean 初始化后的处理： postProcessAfterInitialization</p>
<p>因为自动定义注解是这样被使用于service Bean的，所以服务注册是需要在bean初始化前执行<img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173607.png"><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173638.png">自定义服务发现的注解作用于controller Bean的属性字段上，所以是在Bean初始化后在对其进行处理<img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173819.png"><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230104173944.png"></p>
]]></content>
  </entry>
  <entry>
    <title>会话管理</title>
    <url>/2022/11/25/Session/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Cookie-Session-Token"><a href="#Cookie-Session-Token" class="headerlink" title="Cookie, Session, Token"></a>Cookie, Session, Token</h3><p>Cookie： <del>小饼干</del>(bushi)，是保存在客户端的一小份数据(不允许超过4KB)<br>Session： 术语叫会话控制，是一种在客户端与服务端之间保持状态的解决方案，通常会在服务端的一份数据来记录会话状态<br>Token：令牌，是校验的凭证，可以理解为cookie中存的session id亦或是存在localstorage中的jwt字符串</p>
<div class="note success"><p> Q：为什么我们登录过一次之后下一次再访问就不需要登录了？<br>A：通常在应用层HTTP都是作为无状态协议，每个请求都是完全独立且每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更，即使在 HTTP&#x2F;1.1 上，同一个连接允许传输多个 HTTP 请求的情况下，如果第一个请求出错了，后面的请求一般也能够继续处理（当然，如果导致协议解析失败、消息分片错误之类的自然是要除外的）那么让http请求”带上状态“通用流程如下：</p>
</div>
<span id="more"></span>
<p>(1)首次登录：客户端发送请求携带登录信息访问服务端<br>(2)颁发令牌：服务端校验用户账户密码正确后返回客户端一个令牌(Token)<br>(3)再次访问：客户端把Token保存在(Cookie, LoaclStroage)等地方以后的每次请求都携带此令牌</p>
<p>目前比较常用的方式有Cookie-Session, JWT这两种方式都是满足上述的通用流程但又有莫大的差别概述如下</p>
<p>Cookie-Session(特点：有状态):<br>(1)客户端发送请求携带登录信息访问服务端。<br>(2)服务端校验用户账户密码正确后，会在服务端新建一份session同时把session的id返回给客户端一般保存在cookie中。<br>(3)以后的每次请求都会携带cookie中的token信息(session Id)和服务端保存的session做校验。</p>
<p>JSON-Web-Token(特点：去中心化)<br>(1)客户端发送请求携带登录信息访问服务端。<br>(2)服务端校验用户账户密码正确后，会对用户信息，签发时间，过期时间加密生成一段字符串返回给客户端一般保存在LocalStorage中。<br>(3)以后的每次请求都会在headers的Authorization中携带token信息送给服务端解析校验。</p>
<h3 id="思考与讨论"><a href="#思考与讨论" class="headerlink" title="思考与讨论"></a>思考与讨论</h3><div class="note warning"><p>讨论上述两种方案是否有无状态可以用另外一个角度思考，session方案是可以通过服务端删除session来使用户退出登录(结束维持的状态)，而jwt方案的权限有效时间是根据颁发时就决定的，无法在服务端主动使token失效，由此就可以看出这并不是和服务端之间维持的状态 </p>
</div>

<div class="note warning"><p> Q: HTTP 协议是无状态协议，这句话本身到底对不对？<br>A: 实际上，并不全对。HTTP&#x2F;1.1 中有一个 Expect: 100-Continue 的功能，它是这么工作的：<br>在发送大量数据的时候，考虑到服务端有可能直接拒收数据，客户端发出请求头并附带 Expect: 100-Continue 的 HTTP 头，不发送请求体，先等待服务器响应<br>服务器收到 Expect: 100-Continue 的请求，如果允许上传，发送 100 Continue 的 HTTP 响应（同一个请求可以有任意个 1xx 的响应，均不是最后的 Response，只起到提示性作用）；如果不允许，例如不允许上传数据，或者数据大小超出限制，直接返回 4xx&#x2F;5xx 的错误<br>客户端收到 100 Continue 的响应之后，继续上传数据<br>可以看出，这实际上很明显是一个有状态协议的套路，它需要先进行一次握手，然后再真正发送数据。不过，HTTP 协议也规定，如果服务端不进行 100 Continue 的响应，建议客户端在等待较短的时间之后仍然上传数据，以达成与不支持 Expect: 100-Continue 功能的服务器的兼容，这样可以算是“能有状态则有状态，否则回到无状态的路上”，这样说 HTTP 1.x 是无状态的协议也是没错的。<br>例如用netty实现一个http server使用100-continue这一机制<br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230102173338.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230102173530.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230102173550.png"></p>
</div>
<hr>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>Session是保存在服务端的一份数据通常保存在(Tomcat, Jetty)等Web容器中，如果我们的应用实例复制多份以集群方式部署在不同的服务器上，那么请求经过负载均衡后选择服务端访问就会出现已经登录了但session不在此节点而在其他节点的情况。解决办法有tomcat做session复制，负载均衡使用IP_Hash策略，把session作为外部公共资源来存储等。</p>
<p>其他的没实践过只说说最后一种，把session作为外部公共资源来存储，那么一定是一块可以被大家都访问到的内存空间，存储方式通常选用Redis,MongoDB等数据库来存储session信息，我们可以充分利用Redis的kv存储方式，读取速度来便捷的使用session机制。</p>
<h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><p>Spring Session是Spring系列提供的会话管理API，它允许以应用外部容器中立的方式替换HttpSession，也就是说它是将tomcat等web容器中的session抽离出来存放进自定义容器中。<br>详细介绍：<a href="https://docs.spring.io/spring-session/reference/index.html">https://docs.spring.io/spring-session/reference/index.html</a></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>session远优于的</p>
]]></content>
  </entry>
  <entry>
    <title>网络IO</title>
    <url>/2022/09/05/%E7%BD%91%E7%BB%9CIO/</url>
    <content><![CDATA[<h2 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="[0]前置知识"></a>[0]前置知识</h2><h3 id="0-什么是Socket"><a href="#0-什么是Socket" class="headerlink" title="[0] 什么是Socket"></a>[0] 什么是Socket</h3><p>Q: 首先思考一个问题，在代码层面我们如何让客户端和服务端通信<br>A: 这需要编程语言对操作系统底层接口进行封装供我们使用<br>所以socket并非什么额外的技术，它是对底层网络操作进行抽象封装后的接口，使用抽象出的接口固然爽，但同时也对开发者屏蔽了一些底层细节，例如完成tcp三次握手后，连接会存放进Accept队列等待被上层应用程序取走的连接，调用<code>socket.accept()</code>就可以获得该连接然后对其进行操作，所以如果能将网络通信流程结合socket接口来学习会轻松一些。</p>
<div class="note success"><p>[总结]：<br>socket是在应用层和传输层之间的一个抽象层，它把TCP&#x2F;IP层复杂的操作抽象为几个简单的接口供应用层调用，也就是说你不用再管tcp协议细节及send、recv实现细节。简单的说，Socket就是利用服务器和客户端解决进程间通信连接的问题。</p>
</div>

<span id="more"></span>
<h3 id="1-操作系统层面的网络通信原理"><a href="#1-操作系统层面的网络通信原理" class="headerlink" title="[1] 操作系统层面的网络通信原理"></a>[1] 操作系统层面的网络通信原理</h3><p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105203147.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105203212.png"><br><font class='redc'>简单来说就是网络传输的二进制流数据，第一步到达网卡，然后拷贝到内核空间，再由内核空间拷贝到用户空间，最后我们的应用进程读取到该数据进行操作</font><div class="note warning"><p>为什么要这么麻烦？以下为简述<br>为了防止操作系统受程序影响崩溃，所以划分成出了内核空间和用户空间，我们平时写完代码就是运行在用户空间上的，当用户空间里进程想要进行文件，内存等资源调度时，不可以直接访问而是触发操作系统的函数执行系统调用，此时就由用户态转化为内核态<br>参考笔记：<a href="https://www.yuque.com/rlyanpro/vfbdm2/byznm23uifzmn2rl#YfDCD">https://www.yuque.com/rlyanpro/vfbdm2/byznm23uifzmn2rl#YfDCD</a></p>
</div></p>
<h3 id="2-IO模型"><a href="#2-IO模型" class="headerlink" title="[2] IO模型"></a>[2] IO模型</h3><p>结合上面提到的网络数据传输过程来看，<font class='redc'>以用户线程的视角来看IO操作会分成两个阶段，数据准备(网卡拷贝到内核空间)和数据读取(内核空间拷贝到用户空间)</font><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105203900.png"><br><font class='redc'>第一阶段来判断同步，异步：</font>是否需要主动读写数据,是为同步，否为异步，这一阶段与阻塞非阻塞无关<br><font class='redc'>第二阶段判断阻塞，非阻塞：</font>⽆需主动读写数据，由操作系统内核完成数据的读写, 等待完成通知<br>以下是五种IO模型<br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105205323.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105205349.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105205408.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105205427.png"><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105205447.png"></p>
<h2 id="1-Socket-BIO"><a href="#1-Socket-BIO" class="headerlink" title="[1] Socket BIO"></a>[1] Socket BIO</h2><p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">//输入流</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端跟你说：&quot;</span>+str);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出流</span></span><br><span class="line">                bw.write(scanner.next());</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BioClientExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.2&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//获取输入流输出流</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//输出流</span></span><br><span class="line">            bw.write(scanner.next());</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">            <span class="comment">//输入流</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端跟你说：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写完测试会发现，如果有两个客户端那它们没办法同时和服务端通信，也就是说服务端不具备处理多连接的能力<br>那么我们可以accept拿到连接后为每一个连接都分配一个线程工作，这样就有了处理多连接的能力<br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105213321.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BioServerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//循环监听</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(socket.getRemoteSocketAddress());</span><br><span class="line">            executor.submit(<span class="keyword">new</span> <span class="title class_">ServerHandler</span>(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; !socket.isClosed()) &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">                <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端说：&quot;</span> + data);</span><br><span class="line">                bw.write(<span class="string">&quot;fuck  you client&quot;</span>);</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写完测试后会发现，虽然服务端有了处理多连接的能力，但处理连接使用的是线程池中的线程，如果客户端通信后不进行断开那么会一直占用该线程，这样就没法还给线程池进行复用了，所以结合资源开销，并发效率来看还是不大行。 （但这不是说bio就一定不行，在处理响应速度比较快的短链接时bio非常合适）</p>
<h2 id="2-Socket-Nio"><a href="#2-Socket-Nio" class="headerlink" title="[2] Socket Nio"></a>[2] Socket Nio</h2><p>在Java中使用Selector(多路复用选择器)来实现NIO<br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105213505.png"><br>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioServerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> getSelector();</span><br><span class="line">        listen(selector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建可选通道，设置非阻塞</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定通道到指定端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocketChannel.socket();</span><br><span class="line">        socket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向selector注册IO事件,首先注册SelectionKey.OP_ACCEPT让server accept监听</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listen</span><span class="params">(Selector selector)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">//判断IO事件类型进行处理</span></span><br><span class="line">                process(selector, key);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Selector selector, SelectionKey key)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; =&gt;事件类型 accept&quot;</span>);</span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;远程地址：&quot;</span> + channel.getRemoteAddress());</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; =&gt;事件类型 read&quot;</span>);</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">500</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer.array(), <span class="number">0</span>, len);</span><br><span class="line">                System.out.println(<span class="string">&quot;收到内容：&quot;</span> + content);</span><br><span class="line">                channel.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; =&gt;事件类型 write&quot;</span>);</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;client fuck you I am Nio Server&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送内容：&quot;</span> + str);</span><br><span class="line">            channel.write(ByteBuffer.wrap(str.getBytes()));</span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="comment">//            channel.close(); //向客户端发送数据后管别此通道连接</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioClientExample0</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.setOption(StandardSocketOptions.TCP_NODELAY, <span class="literal">true</span>);</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer0</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> socketChannel.read(byteBuffer1);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(byteBuffer1.array(), <span class="number">0</span>, len));</span><br><span class="line">            byteBuffer1.clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            info = scanner.next();</span><br><span class="line">            byteBuffer0.put(info.getBytes());</span><br><span class="line">            byteBuffer0.flip();</span><br><span class="line">            socketChannel.write(byteBuffer0);</span><br><span class="line">            byteBuffer0.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写完测试会发现，始终都只有main线程来处理socket的accept，read，write，但依然具备处理多连接的能力，这是因为我们把接受连接和读写的IO操作作为事件注册得到复用器上，然后判断当前复用器可以执行哪些操作<br>例如这里，我们服务端在处理完写事件返回客户端数据后，给复用器注册上读事件<code>channel.register(selector, SelectionKey.OP_READ);</code>让它准备接收新的数据而我客户端还没发送时，此时另一个客户端进行了连接，复用器被注册上accept事件，所以立马就处理了accept接收了连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; =&gt;事件类型 write&quot;</span>);</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;client fuck you I am Nio Server&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送内容：&quot;</span>+str);</span><br><span class="line">            channel.write(ByteBuffer.wrap(str.getBytes()));</span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230105211708.png"></p>
<h2 id="3-Reactor模式"><a href="#3-Reactor模式" class="headerlink" title="[3] Reactor模式"></a>[3] Reactor模式</h2><p>上面了使用多路复用器selector实现了socket nio，实现的关键是抽象出io的行为作为事件注册进selector，进一步进行抽象会得到更清晰的模型Reactor（以事件为驱动）<img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230106111800.png">上面的demo是我在了解整个知识体系并学完后写的，所以能够看见Reactor的影子，例如listen对应的就是acceptor，proces对应dispatch。上面的例子也看到了，无论是accept，read，write操作都是在main线程执行的，那么一旦出现了耗时操作，就会导致所有请求处理全部延时，造成阻塞，影响系统性能。<br><font class='redc'>所以又延伸出了另一个模型：单Reactor多线程模型（main线程主管reactor，而reactor下发的任务是多线处理的）</font><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230106122156.png"><br>虽然单Reactor多线程模型已经能够处理大量的连接请求，但是由于单Reactor中所有的连接建立、读取、响应都在Reactor线程中处理，无疑是增大了Reactor的压力，在高并发场景下容易成为性能瓶颈，于是就出现了主从Reactor。在主从Reactor多线程模型中，<font class='redc'>主Reactor仅仅负责处理连接，建立连接后将Channel注册到子Reactor中，进行处理IO读写，然后交给线程池处理业务，netty框架就是基于该模型实现的，其中主Reactor在Netty中对应Boss group 线程组，子Reactor对应Worker Group 线程组。主Reactor仅负责建立连接，工作简单，一般设置1个线程就足够。在主Reactor建立好连接后，将其注册到Worker Group线程组，触发相应的IO事件，最终由Pipeline中的多个Handler进行有序处理</font><br><img src="https://blog-rylan.oss-cn-beijing.aliyuncs.com/image/20230106122852.png"></p>
]]></content>
  </entry>
</search>
